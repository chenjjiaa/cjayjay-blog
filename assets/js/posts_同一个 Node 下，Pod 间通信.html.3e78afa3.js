"use strict";(self.webpackChunkcjayjay_blog=self.webpackChunkcjayjay_blog||[]).push([[157],{6262:(s,n)=>{n.A=(s,n)=>{const e=s.__vccOpts||s;for(const[s,i]of n)e[s]=i;return e}},2903:(s,n,e)=>{e.r(n),e.d(n,{comp:()=>d,data:()=>p});var i=e(641),a=e(33);const l={},d=(0,e(6262).A)(l,[["render",function(s,n){const e=(0,i.g2)("VPCard");return(0,i.uX)(),(0,i.CE)("div",null,[n[0]||(n[0]=(0,i.Fv)('<h1 id="同一个-node-下-pod-间通信" tabindex="-1"><a class="header-anchor" href="#同一个-node-下-pod-间通信"><span>同一个 Node 下，Pod 间通信</span></a></h1><p>Pod 间进行通信依赖于两个主要的设备，一个是虚拟网络设备（成对存在）。虚拟网络设备的一端接在 Pod 的网络命名空间中，他的另一端是接在宿主机的网络命名空间中（这是一个全局的网络命名空间）。 然后宿主机的命名空间又包含有 <code>cni0</code> 这个网桥设备，然后这个网桥会将报文发送到另一端的与他相连的另一个 Pod 的虚拟网络设备的一端，从而通过这个虚拟网络设备将数据发送到另一个 Pod 当中</p><p>pod1 -&gt; pod1&#39;s eth0 -&gt; node&#39;s veth0 -&gt; node&#39;s cni0 -&gt; node&#39;s veth1 -&gt; pod2&#39;s eth0 -&gt; pod2</p><p>怎么验证这些虚拟网络设备是和 <code>cni0</code> 连接在一起的呢？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>brctl show</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>而这些虚拟网络设备是连接到当前 Node 的网络命名空间的</p><p>查看当前 K8s Node 上有多少个网络命名空间？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ip netns list</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span># 输出：</span></span>\n<span class="line"><span>root@cjj-workspace ～&gt; ip netns</span></span>\n<span class="line"><span>cni-2180b3ea-73e3-5960-40a5-0e5f792f7530 (id: 115)</span></span>\n<span class="line"><span>cni-b33d0d90-b4a5-6345-e0c3-4e8758d982c1 (id: 119)</span></span>\n<span class="line"><span>cni-afe4707f-873e-0aae-b727-c7fb37f375d2 (id: 123)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何知道某个 Pod 是在哪一个网络命名空间中的?</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 先拿到 ip，也就是说这个 ip 必然会在 ip nets list 中的某一个或多个网络命名空间中</span></span>\n<span class="line"><span>kubectl get pods -o wide</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span># 怎么知道哪个网络命名空间有这个 ip 呢？将这些命名空间一个一个去试！</span></span>\n<span class="line"><span># 查看某命名空间下的网络设备，查看 eth0 的 ip。eth0 是这个 Pod 对外的接口（虚拟网络设备的另一端）</span></span>\n<span class="line"><span>sudo ip netns exec &lt;网络命名空间id&gt; ip a</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一些指令：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>查看宿主机的网络设备：</span></span>\n<span class="line"><span>ip a</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>有多少个网络命名空间：</span></span>\n<span class="line"><span>ip nets list</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>如何看到pod的ip是在哪个命名空间下呢？</span></span>\n<span class="line"><span>kubectl get pods</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>首先得知道 pod 的 ip</span></span>\n<span class="line"><span>kubectl get pods -o wide</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>其次要知道网络命名空间的详情，看看 eth0 是不是与该 pod 的 ip 对应</span></span>\n<span class="line"><span>sudo ip netns exec &lt;net_namespace&gt; ip a</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ps：kubectl 等命令可以设置别名：<code>alias k=&#39;kubectl&#39;</code>。kubectl 等命令，可以简化为自定义别名</p><h2 id="验证数据传输" tabindex="-1"><a class="header-anchor" href="#验证数据传输"><span>验证数据传输</span></a></h2><p>验证报文是沿着 Pod A eth0 -&gt; 宿主机 vethxxx -&gt; cni0 -&gt; 宿主机 vethyyy -&gt; Pod B eth0 这条路径传输</p><ul><li>先在 Node 宿主机上监听 veth 或 cni0 这些网络设备（因为 Pod A 给 Pod B 传输报文必定会经过这几个网络接口）</li><li>再启动另一个窗口，进入 Pod A，然后向 Pod B 的 ip 来 ping 一下</li></ul><p>在宿主机监听网络设备</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>sudo tcpdump -i &lt;net_interface_name&gt; -nn icmp</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span># 捕获端口为 80 的 HTTP 流量</span></span>\n<span class="line"><span>sudo tcpdump -i &lt;net_interface_name&gt; -nn tcp port 80</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Pod A 中向 Pod B 发起 ping 请求</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>kubectl exec -it &lt;pod_a_name&gt; -- bash</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span># 向目标 ip 发送三次 ping 请求即可</span></span>\n<span class="line"><span>ping -c 3 &lt;destination_ip&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',20)),(0,i.bF)(e,(0,a._B)((0,i.Ng)({title:"chenjjiaa",desc:"沉浸在万花筒的幻术之中吧...",logo:"./github-logo.jpg",link:"https://github.com/chenjjiaa",background:"rgba(253, 230, 138, 0.15)"})),null,16)])}]]),p=JSON.parse('{"path":"/posts/%E5%90%8C%E4%B8%80%E4%B8%AA%20Node%20%E4%B8%8B%EF%BC%8CPod%20%E9%97%B4%E9%80%9A%E4%BF%A1.html","title":"同一个 Node 下，Pod 间通信","lang":"zh-CN","frontmatter":{"title":"同一个 Node 下，Pod 间通信","date":"2024-08-12T00:00:00.000Z","tag":["后端","kubernetes"],"star":true,"sticky":false,"excerpt":"<p>Pod 间进行通信依赖于两个主要的设备，一个是虚拟网络设备（成对存在）。虚拟网络设备的一端接在 Pod 的网络命名空间中，他的另一端是接在宿主机的网络命名空间中（这是一个全局的网络命名空间）。</p>"},"headers":[{"level":2,"title":"验证数据传输","slug":"验证数据传输","link":"#验证数据传输","children":[]}],"git":{"createdTime":1727023492000,"updatedTime":1727023492000,"contributors":[{"name":"励志买套上海苏河湾大平层","email":"94773058+chenjjiaa@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":2.94,"words":883},"filePathRelative":"posts/同一个 Node 下，Pod 间通信.md","localizedDate":"2024年8月12日"}')}}]);